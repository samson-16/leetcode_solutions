# Last updated: 6/16/2025, 11:50:17 PM


class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX == rootY:
            return False
        if self.size[rootX] < self.size[rootY]:
            rootX, rootY = rootY, rootX
        self.parent[rootY] = rootX
        self.size[rootX] += self.size[rootY]
        return True

    def get_size(self, x):
        return self.size[self.find(x)]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        dsu = DSU(n)

        # Union connected nodes
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j]:
                    dsu.union(i, j)

        # Count how many initial infections are in each component
        infected_in_component = Counter()
        for node in initial:
            root = dsu.find(node)
            infected_in_component[root] += 1

        # Sort initial so we return smallest index in case of tie
        initial.sort()
        best_node = initial[0]
        max_saved = -1

        for node in initial:
            root = dsu.find(node)
            if infected_in_component[root] == 1:  # only one infected in the component
                saved = dsu.get_size(root)
                if saved > max_saved:
                    max_saved = saved
                    best_node = node

        return best_node
